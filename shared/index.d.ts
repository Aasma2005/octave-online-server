/** Declaration file generated by dts-gen */

export class JSONStreamSafe {
    constructor(...args: any[]);

    static captureRejectionSymbol: any;

    static captureRejections: boolean;

    static defaultMaxListeners: number;

    static errorMonitor: any;

    static getEventListeners(emitterOrTarget: any, type: any): any;

    static init(opts: any): void;

    static kMaxEventTargetListeners: any;

    static kMaxEventTargetListenersWarned: any;

    static listenerCount(emitter: any, type: any): any;

    static on(emitter: any, event: any, options: any): any;

    static once(emitter: any, name: any, options: any): any;

    static setMaxListeners(n: any, eventTargets: any): void;

    static usingDomains: boolean;

}

export class OnlineOffline {
    constructor(...args: any[]);

    create(...args: any[]): void;

    destroy(...args: any[]): void;

    isOnline(...args: any[]): void;

    static captureRejectionSymbol: any;

    static captureRejections: boolean;

    static defaultMaxListeners: number;

    static errorMonitor: any;

    static getEventListeners(emitterOrTarget: any, type: any): any;

    static init(opts: any): void;

    static kMaxEventTargetListeners: any;

    static kMaxEventTargetListenersWarned: any;

    static listenerCount(emitter: any, type: any): any;

    static on(emitter: any, event: any, options: any): any;

    static once(emitter: any, name: any, options: any): any;

    static setMaxListeners(n: any, eventTargets: any): void;

    static usingDomains: boolean;

}

export class Queue {
    constructor(...args: any[]);

    dequeue(...args: any[]): void;

    enqueue(...args: any[]): void;

    isEmpty(...args: any[]): void;

    peek(...args: any[]): void;

    removeAll(...args: any[]): void;

    size(...args: any[]): void;

    static captureRejectionSymbol: any;

    static captureRejections: boolean;

    static defaultMaxListeners: number;

    static errorMonitor: any;

    static getEventListeners(emitterOrTarget: any, type: any): any;

    static init(opts: any): void;

    static kMaxEventTargetListeners: any;

    static kMaxEventTargetListenersWarned: any;

    static listenerCount(emitter: any, type: any): any;

    static on(emitter: any, event: any, options: any): any;

    static once(emitter: any, name: any, options: any): any;

    static setMaxListeners(n: any, eventTargets: any): void;

    static usingDomains: boolean;

}

export class RedisMessenger {
    constructor(...args: any[]);

    applyOtOperation(...args: any[]): void;

    changeOtDocId(...args: any[]): void;

    close(...args: any[]): void;

    destroyD(...args: any[]): void;

    destroyOtDoc(...args: any[]): void;

    destroyU(...args: any[]): void;

    enableOtScriptsSync(...args: any[]): void;

    enableSessCodeScriptsSync(...args: any[]): void;

    getSessCode(...args: any[]): void;

    getSessCodeFlavor(...args: any[]): void;

    getWorkspaceSessCode(...args: any[]): void;

    input(...args: any[]): void;

    isValid(...args: any[]): void;

    loadOtDoc(...args: any[]): void;

    otMsg(...args: any[]): void;

    output(...args: any[]): void;

    putSessCode(...args: any[]): void;

    putSessCodeFlavor(...args: any[]): void;

    replyToFlavorStatus(...args: any[]): void;

    replyToRebootRequest(...args: any[]): void;

    requestFlavorStatus(...args: any[]): void;

    requestReboot(...args: any[]): void;

    setLive(...args: any[]): void;

    setOtDocContent(...args: any[]): void;

    setWorkspaceSessCode(...args: any[]): void;

    subscribeToDestroyD(...args: any[]): void;

    subscribeToDestroyU(...args: any[]): void;

    subscribeToExpired(...args: any[]): void;

    subscribeToFlavorStatus(...args: any[]): void;

    subscribeToInput(...args: any[]): void;

    subscribeToOtMsgs(...args: any[]): void;

    subscribeToOutput(...args: any[]): void;

    subscribeToRebootRequests(...args: any[]): void;

    subscribeToWorkspaceMsgs(...args: any[]): void;

    touchInput(...args: any[]): void;

    touchOtDoc(...args: any[]): void;

    touchOutput(...args: any[]): void;

    touchWorkspace(...args: any[]): void;

    workspaceMsg(...args: any[]): void;

    static captureRejectionSymbol: any;

    static captureRejections: boolean;

    static defaultMaxListeners: number;

    static errorMonitor: any;

    static getEventListeners(emitterOrTarget: any, type: any): any;

    static init(opts: any): void;

    static kMaxEventTargetListeners: any;

    static kMaxEventTargetListenersWarned: any;

    static listenerCount(emitter: any, type: any): any;

    static on(emitter: any, event: any, options: any): any;

    static once(emitter: any, name: any, options: any): any;

    static setMaxListeners(n: any, eventTargets: any): void;

    static usingDomains: boolean;

}

export class RedisQueue {
    constructor(...args: any[]);

    enqueueMessage(...args: any[]): void;

    reset(...args: any[]): void;

    static captureRejectionSymbol: any;

    static captureRejections: boolean;

    static defaultMaxListeners: number;

    static errorMonitor: any;

    static getEventListeners(emitterOrTarget: any, type: any): any;

    static init(opts: any): void;

    static kMaxEventTargetListeners: any;

    static kMaxEventTargetListenersWarned: any;

    static listenerCount(emitter: any, type: any): any;

    static on(emitter: any, event: any, options: any): any;

    static once(emitter: any, name: any, options: any): any;

    static setMaxListeners(n: any, eventTargets: any): void;

    static usingDomains: boolean;

}

export class StdioMessenger {
    constructor(...args: any[]);

    sendMessage(...args: any[]): void;

    setReadStream(...args: any[]): void;

    setWriteStream(...args: any[]): void;

    static captureRejectionSymbol: any;

    static captureRejections: boolean;

    static defaultMaxListeners: number;

    static errorMonitor: any;

    static getEventListeners(emitterOrTarget: any, type: any): any;

    static init(opts: any): void;

    static kMaxEventTargetListeners: any;

    static kMaxEventTargetListenersWarned: any;

    static listenerCount(emitter: any, type: any): any;

    static on(emitter: any, event: any, options: any): any;

    static once(emitter: any, name: any, options: any): any;

    static setMaxListeners(n: any, eventTargets: any): void;

    static usingDomains: boolean;

}

export const config: {
    ads: {
        abox_html: string;
        disabled: boolean;
        head_html: string;
    };
    auth: {
        easy: {
            max_token_age: number;
            secret: string;
        };
        google: {
            oauth_key: string;
            oauth_secret: string;
        };
        password: {
            delay: number;
            salt_rounds: number;
        };
        utils_admin: {
            users: {
                webmaster: string;
            };
        };
    };
    client: {
        announcement_display: string;
        announcement_html: string;
        app_name: string;
        description_key: string;
        gacode: string;
        onboarding: boolean;
        theme_collection: string;
        theme_color: string;
        title_key: string;
        uservoice: string;
        welcome_back_ms: number;
    };
    docker: {
        cpuShares: number;
        cwd: string;
        diskQuotaKiB: number;
        gitdir: string;
        images: {
            filesystemSuffix: string;
            octaveSuffix: string;
        };
        memoryShares: string;
    };
    email: {
        from: string;
        productName: string;
        provider: string;
        supportUrl: string;
    };
    flavorCommon: {
        blockVolume: boolean;
        defaultClusterSize: number;
        idleTime: number;
        image_uuid: string;
        network_uuid: string;
        statusInterval: number;
    };
    flavors: {
        basic: {
            blockVolume: boolean;
            rackspaceFlavor: string;
        };
        memory: {
            rackspaceFlavor: string;
        };
    };
    front: {
        cookie: {
            max_age: number;
            name: string;
            secret: string;
        };
        flavor_log_interval: number;
        hostname: string;
        listen_port: number;
        locales: string[];
        locales_path: string;
        port: number;
        protocol: string;
        require_https: boolean;
        socket_io_path: string;
        static_path: string;
        view_cache_clear_interval: number;
    };
    gcp: {
        archive_bucket: string;
        artifacts_bucket: string;
        credentials: {
            auth_provider_x509_cert_url: string;
            auth_uri: string;
            client_email: string;
            client_id: string;
            client_x509_cert_url: string;
            private_key: string;
            private_key_id: string;
            project_id: string;
            token_uri: string;
            type: string;
        };
        health_check_port: number;
        i18next_locales_tar_gz: string;
        instance_group_name: string;
        instance_group_removal_method: string;
        snapshots_bucket: string;
        snapshots_duration: number;
        zone: string;
    };
    git: {
        author: {
            email: string;
            name: string;
        };
        autoCommitInterval: number;
        commitTimeLimit: number;
        createRepoPort: number;
        gitDaemonPort: number;
        hostname: string;
        httpUrl: string;
        supportsAllowUnrelatedHistories: boolean;
    };
    gith: {
        hostname: string;
    };
    mailgun: {
        api_key: string;
        domain: string;
    };
    maintenance: {
        interval: number;
        maxNodesInMaintenance: number;
        minNodesInCluster: number;
        pauseDuration: number;
        requestInterval: number;
        responseWaitTime: number;
    };
    mongo: {
        db: string;
        hostname: string;
        port: number;
    };
    ot: {
        document_expire: {
            interval: number;
            timeout: number;
        };
        operation_expire: number;
        stats_interval: number;
    };
    patreon: {
        client_id: string;
        client_secret: string;
        login_redirect: string;
        redirect_url: string;
        state_max_token_age: number;
        state_secret: string;
        tiers: {
            "4941716": {
                name: string;
                oo_tier: string;
            };
            "4941717": {
                name: string;
                oo_tier: string;
            };
            "4941718": {
                name: string;
                oo_tier: string;
            };
            "4994534": {
                name: string;
                oo_tier: string;
            };
        };
        webhook_secret: string;
    };
    postmark: {
        onDemandSnapshots: {
            stream: string;
            template: string;
        };
        serverToken: string;
        templateAlias: string;
    };
    rackspace: {
        api_key: string;
        identity_base_url: string;
        personality_filename: string;
        servers_base_url: string;
        username: string;
    };
    recaptcha: {
        secretKey: string;
        siteKey: string;
    };
    redirect: {
        hostname: string;
    };
    redis: {
        expire: {
            interval: number;
            timeout: number;
            timeoutShort: number;
        };
        hostname: string;
        maxPayload: number;
        options: {
            auth_pass: string;
        };
        port: number;
    };
    selinux: {
        cgroup: {
            conf: string;
            cpuPeriod: number;
            cpuQuota: number;
            gid: string;
            name: string;
            uid: string;
        };
        prlimit: {
            addressSpace: number;
        };
    };
    session: {
        countdownExtraTime: number;
        countdownRequestTime: number;
        countdownRequestTimeBuffer: number;
        implementation: string;
        jsonMaxMessageLength: number;
        legalTime: {
            guest: number;
            user: number;
        };
        payloadAcknowledgeDelay: number;
        payloadLimit: {
            guest: number;
            user: number;
        };
        payloadMessageDelay: number;
        textFileSizeLimit: number;
        timeoutTime: number;
        timewarnMessage: string;
        timewarnTime: number;
        urlreadMaxBytes: number;
        urlreadPatterns: string[];
    };
    sessionManager: {
        logInterval: number;
        poolInterval: number;
        poolSize: number;
        poolTier: boolean;
        queueBoostTime: number;
        startupTimeLimit: number;
    };
    statsd: {
        hostname: string;
        port: number;
    };
    tiers: {
        root: {
            "ads.disabled": boolean;
            "sessionManager.poolTier": string;
            "sessionManager.queueBoostTime": number;
        };
        vip: {
            "ads.disabled": boolean;
            "selinux.cgroup.name": string;
            "selinux.prlimit.addressSpace": number;
            "session.countdownExtraTime": number;
            "session.countdownRequestTime": number;
            "session.legalTime.user": number;
            "session.payloadLimit.user": number;
            "session.timeoutTime": number;
            "session.timewarnTime": number;
            "sessionManager.poolSize": number;
            "sessionManager.queueBoostTime": number;
        };
    };
    worker: {
        clockInterval: {
            max: number;
            min: number;
        };
        clockStrategy: string;
        logDir: string;
        maxSessions: number;
        monitorLogs: {
            subdir: string;
        };
        onDisconnect: string;
        sessionLogs: {
            depth: number;
            subdir: string;
        };
        token: string;
        uid: number;
    };
};

export function asyncCache(getter: any, bufferTime: any): any;

export function hostname(): any;

export function logger(id: any): any;

export function onceMessage(emitter: any, messageName: any, next: any): void;

export function silent(messageRegex: any, next: any, ...args: any[]): any;

export function timeLimit(milliseconds: any, defaults: any, callback: any, ...args: any[]): any;

export namespace JSONStreamSafe {
    class EventEmitter {
        constructor(opts: any);

        addListener(type: any, listener: any): any;

        emit(type: any, args: any): any;

        eventNames(): any;

        getMaxListeners(): any;

        listenerCount(type: any): any;

        listeners(type: any): any;

        off(type: any, listener: any): any;

        on(type: any, listener: any): any;

        once(type: any, listener: any): any;

        prependListener(type: any, listener: any): any;

        prependOnceListener(type: any, listener: any): any;

        rawListeners(type: any): any;

        removeAllListeners(type: any, ...args: any[]): any;

        removeListener(type: any, listener: any): any;

        setMaxListeners(n: any): any;

        static EventEmitter: any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static defaultMaxListeners: number;

        static errorMonitor: any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

}

export namespace OnlineOffline {
    class EventEmitter {
        constructor(opts: any);

        addListener(type: any, listener: any): any;

        emit(type: any, args: any): any;

        eventNames(): any;

        getMaxListeners(): any;

        listenerCount(type: any): any;

        listeners(type: any): any;

        off(type: any, listener: any): any;

        on(type: any, listener: any): any;

        once(type: any, listener: any): any;

        prependListener(type: any, listener: any): any;

        prependOnceListener(type: any, listener: any): any;

        rawListeners(type: any): any;

        removeAllListeners(type: any, ...args: any[]): any;

        removeListener(type: any, listener: any): any;

        setMaxListeners(n: any): any;

        static EventEmitter: any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static defaultMaxListeners: number;

        static errorMonitor: any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

}

export namespace Queue {
    class EventEmitter {
        constructor(opts: any);

        addListener(type: any, listener: any): any;

        emit(type: any, args: any): any;

        eventNames(): any;

        getMaxListeners(): any;

        listenerCount(type: any): any;

        listeners(type: any): any;

        off(type: any, listener: any): any;

        on(type: any, listener: any): any;

        once(type: any, listener: any): any;

        prependListener(type: any, listener: any): any;

        prependOnceListener(type: any, listener: any): any;

        rawListeners(type: any): any;

        removeAllListeners(type: any, ...args: any[]): any;

        removeListener(type: any, listener: any): any;

        setMaxListeners(n: any): any;

        static EventEmitter: any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static defaultMaxListeners: number;

        static errorMonitor: any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

}

export namespace RedisMessenger {
    class EventEmitter {
        constructor(opts: any);

        addListener(type: any, listener: any): any;

        emit(type: any, args: any): any;

        eventNames(): any;

        getMaxListeners(): any;

        listenerCount(type: any): any;

        listeners(type: any): any;

        off(type: any, listener: any): any;

        on(type: any, listener: any): any;

        once(type: any, listener: any): any;

        prependListener(type: any, listener: any): any;

        prependOnceListener(type: any, listener: any): any;

        rawListeners(type: any): any;

        removeAllListeners(type: any, ...args: any[]): any;

        removeListener(type: any, listener: any): any;

        setMaxListeners(n: any): any;

        static EventEmitter: any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static defaultMaxListeners: number;

        static errorMonitor: any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

}

export namespace RedisQueue {
    class EventEmitter {
        constructor(opts: any);

        addListener(type: any, listener: any): any;

        emit(type: any, args: any): any;

        eventNames(): any;

        getMaxListeners(): any;

        listenerCount(type: any): any;

        listeners(type: any): any;

        off(type: any, listener: any): any;

        on(type: any, listener: any): any;

        once(type: any, listener: any): any;

        prependListener(type: any, listener: any): any;

        prependOnceListener(type: any, listener: any): any;

        rawListeners(type: any): any;

        removeAllListeners(type: any, ...args: any[]): any;

        removeListener(type: any, listener: any): any;

        setMaxListeners(n: any): any;

        static EventEmitter: any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static defaultMaxListeners: number;

        static errorMonitor: any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

}

export namespace StdioMessenger {
    class EventEmitter {
        constructor(opts: any);

        addListener(type: any, listener: any): any;

        emit(type: any, args: any): any;

        eventNames(): any;

        getMaxListeners(): any;

        listenerCount(type: any): any;

        listeners(type: any): any;

        off(type: any, listener: any): any;

        on(type: any, listener: any): any;

        once(type: any, listener: any): any;

        prependListener(type: any, listener: any): any;

        prependOnceListener(type: any, listener: any): any;

        rawListeners(type: any): any;

        removeAllListeners(type: any, ...args: any[]): any;

        removeListener(type: any, listener: any): any;

        setMaxListeners(n: any): any;

        static EventEmitter: any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static defaultMaxListeners: number;

        static errorMonitor: any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

}

export namespace config2 {
    function flavor(flavor: any): any;

    function tier(tier: any): any;

}

export namespace gitarchive {
    function createRepoSnapshot(tld: any, name: any, outStream: any): any;

    function generateFilename(name: any): any;

    function repoContainsRefs(tld: any, name: any): any;

    function restoreRepoFromZipFile(log: any, tld: any, name: any, branchName: any, zipFileBlob: any): void;

}

export namespace metrics {
    function gauge(id: any, value: any): any;

}

export namespace redisUtil {
    function createClient(): any;

    function getSessCodeFromChannel(channel: any): any;

    function isValidSessCode(sessCode: any): any;

    namespace chan {
        const destroyD: string;

        const destroyU: string;

        const needsOctave: string;

        const rebootRequest: string;

        function attachment(id: any): any;

        function flavorStatus(flavor: any): any;

        function input(sessCode: any): any;

        function needsOctaveFlavor(flavor: any): any;

        function otCnt(docId: any): any;

        function otDoc(docId: any): any;

        function otOps(docId: any): any;

        function otSub(docId: any): any;

        function output(sessCode: any): any;

        function session(sessCode: any): any;

        function wsSess(wsId: any): any;

        function wsSub(wsId: any): any;

    }

}

